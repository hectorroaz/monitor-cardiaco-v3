<script>
    // --- Variables globales y constantes
    let heartRateCharacteristic = null, bleDevice = null;
    let lastHR = null, zoneActual = 1;
    let sessionInterval = null, sessionStart = null, sessionElapsed = 0, sessionRunning = false, secondsInZone = 0;
    let hrHistory = [], maxHRInSession = 0, hrSum = 0;
    
    // NUEVO: Variable para gestionar el Wake Lock de forma más robusta
    let wakeLock = null;

    let ZONAS = [
      { id: 1, nombre: "Zona 1", rango: "94–113 bpm", min: 94, max: 113, label: "Z1" },
      { id: 2, nombre: "Zona 2", rango: "113–132 bpm", min: 113, max: 132, label: "Z2" },
      { id: 3, nombre: "Zona 3", rango: "132–150 bpm", min: 132, max: 150, label: "Z3" },
      { id: 4, nombre: "Zona 4", rango: "150–169 bpm", min: 150, max: 169, label: "Z4" },
    ];
    const HR_ZONES_CLASSES = ['hr-blue', 'hr-green', 'hr-yellow', 'hr-orange', 'hr-red'];

    // --- Cacheo de Elementos del DOM
    const ui = {
        connectBtn: document.getElementById('connectBluetooth'),
        statusElem: document.getElementById('bluetoothStatus'),
        hrDisplay: document.getElementById('heartRateDisplay'),
        heartIcon: document.getElementById('heartIcon'),
        fullscreenBtn: document.getElementById('fullscreenBtn'),
        fullscreenContainer: document.getElementById('fullscreenContainer'),
        exitFullscreenBtn: document.getElementById('exitFullscreenBtn'),
        resultMsg: document.getElementById('resultMsg'),
        sessionTime: document.getElementById('sessionTime'),
        playBtn: document.getElementById('sessionPlayBtn'),
        pauseBtn: document.getElementById('sessionPauseBtn'),
        resetBtn: document.getElementById('resetSessionBtn'),
        hrProto: document.getElementById('fullscreenHeartRateProto'),
        hrVisible: document.getElementById('fullscreenHeartRateVisible'),
        arrow: document.getElementById('indicadorFlecha'),
        zoneBtnsRow: document.getElementById('zoneBtnsRow'),
        zoneDesc: document.getElementById('zoneDesc'),
        editZonesBtn: document.getElementById('editZonesBtn'),
        zoneEditorModal: document.getElementById('zoneEditorModal'),
        closeModalBtn: document.getElementById('closeModalBtn'),
        saveZonesBtn: document.getElementById('saveZonesBtn'),
        calculateZonesBtn: document.getElementById('calculateZonesBtn'),
        userAgeInput: document.getElementById('userAge'),
        zoneInputsContainer: document.getElementById('zoneInputsContainer'),
    };
    
    // ---- Lógica del Wake Lock (Mantenimiento de Pantalla Activa) ----
    
    // NUEVO: Función para solicitar el Wake Lock.
    const requestWakeLock = async () => {
        if ('wakeLock' in navigator) {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock activado.');
                // Escucha si el sistema libera el lock (ej: al cambiar de tab)
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock liberado por el sistema.');
                    // Al ser liberado, lo ponemos en null, pero no intentamos readquirirlo aquí,
                    // sino cuando la página vuelva a ser visible.
                    wakeLock = null; 
                });
            } catch (err) {
                console.error(`${err.name}, ${err.message}`);
            }
        } else {
            console.warn('Wake Lock API no soportada.');
        }
    };

    // NUEVO: Función para liberar el Wake Lock.
    const releaseWakeLock = () => {
        if (wakeLock !== null) {
            wakeLock.release();
            wakeLock = null;
            console.log('Wake Lock liberado por la aplicación.');
        }
    };

    // ---- Lógica de la aplicación ----

    function openZoneEditor() {
        let inputsHtml = '';
        ZONAS.forEach(z => {
            inputsHtml += `<div class="grid grid-cols-4 gap-2 items-center">
                <label class="text-right font-semibold pr-2">${z.label}:</label>
                <input type="number" data-zone-id="${z.id}" data-type="min" class="modal-input" value="${z.min}">
                <input type="number" data-zone-id="${z.id}" data-type="max" class="modal-input" value="${z.max}">
                <span class="text-xs text-gray-400 pl-1">bpm</span>
            </div>`;
        });
        ui.zoneInputsContainer.innerHTML = inputsHtml;
        ui.zoneEditorModal.classList.add('active');
    }

    function closeZoneEditor() { ui.zoneEditorModal.classList.remove('active'); }

    function saveZones() {
        const inputs = ui.zoneInputsContainer.querySelectorAll('input');
        inputs.forEach(input => {
            const zoneId = parseInt(input.dataset.zoneId, 10);
            const type = input.dataset.type;
            const value = parseInt(input.value, 10);
            const zone = ZONAS.find(z => z.id === zoneId);
            if(zone && !isNaN(value)) {
                zone[type] = value;
                zone.rango = `${zone.min}–${zone.max} bpm`;
            }
        });
        localStorage.setItem('customHeartRateZones', JSON.stringify(ZONAS));
        updateZoneVisuals();
        closeZoneEditor();
    }
    
    function loadCustomZones() {
        const savedZones = localStorage.getItem('customHeartRateZones');
        if (savedZones) {
            ZONAS = JSON.parse(savedZones);
        }
    }
    
    function calculateZonesByAge() {
        const age = parseInt(ui.userAgeInput.value, 10);
        if (isNaN(age) || age < 10 || age > 100) {
            alert("Por favor, introduce una edad válida.");
            return;
        }
        const mhr = 220 - age;
        const zonePercentages = [ {min: 0.5, max: 0.6}, {min: 0.6, max: 0.7}, {min: 0.7, max: 0.8}, {min: 0.8, max: 0.9} ];
        
        ui.zoneInputsContainer.querySelectorAll('input').forEach(input => {
            const zoneId = parseInt(input.dataset.zoneId, 10);
            const type = input.dataset.type;
            const percentage = zonePercentages[zoneId - 1][type];
            input.value = Math.round(mhr * percentage);
        });
    }
    
    function updateZoneDesc() {
        const z = ZONAS.find(x => x.id == zoneActual);
        if (z) ui.zoneDesc.innerHTML = `<b>${z.nombre}</b>: <span style="font-weight:700">${z.rango}</span>`;
    }
    
    function updateZoneVisuals() {
        ui.zoneBtnsRow.innerHTML = '';
        ZONAS.forEach(z => {
            const btn = document.createElement("button");
            btn.className = `zone-btn z${z.id}`;
            btn.textContent = z.label;
            btn.title = `${z.nombre} (${z.rango})`;
            btn.dataset.zoneId = z.id;
            if (z.id === zoneActual) btn.classList.add("active");
            ui.zoneBtnsRow.appendChild(btn);
        });
        updateZoneDesc();
    }
    
    function formatDuration(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function startSession() {
      if (!sessionRunning) {
        sessionRunning = true;
        sessionStart = Date.now() - sessionElapsed;
        sessionInterval = setInterval(updateSessionTime, 1000);
      }
    }

    function pauseSession() {
      if (sessionRunning) {
        sessionRunning = false;
        clearInterval(sessionInterval);
        sessionElapsed = Date.now() - sessionStart;
      }
    }

    function resetSession() {
        pauseSession();
        sessionElapsed = 0;
        secondsInZone = 0;
        hrHistory = [];
        maxHRInSession = 0;
        hrSum = 0;
        updateSessionTime();
    }

    function updateSessionTime() {
        const currentElapsed = sessionRunning ? Date.now() - sessionStart : sessionElapsed;
        ui.sessionTime.textContent = formatDuration(currentElapsed);
        
        if (sessionRunning && lastHR && isInZone(lastHR)) {
            secondsInZone++;
        }
    }

    async function connectToBluetooth() {
      if (!navigator.bluetooth) {
        ui.statusElem.textContent = 'Error: Web Bluetooth no es compatible.';
        ui.statusElem.classList.add('text-red-600');
        return;
      }
      try {
        ui.statusElem.textContent = 'Buscando sensor...';
        ui.connectBtn.disabled = true;
        bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ services: ['heart_rate'] }], optionalServices: ['device_information'] });
        
        ui.statusElem.textContent = `Conectando a ${bleDevice.name || 'dispositivo'}...`;
        bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
        const server = await bleDevice.gatt.connect();
        
        const service = await server.getPrimaryService('heart_rate');
        heartRateCharacteristic = await service.getCharacteristic('heart_rate_measurement');
        await heartRateCharacteristic.startNotifications();
        
        ui.statusElem.textContent = '¡Conectado! Escuchando latidos...';
        ui.statusElem.classList.add('text-green-600');
        ui.connectBtn.disabled = false;
        // Se elimina la llamada al WakeLock de aquí.
        heartRateCharacteristic.addEventListener('characteristicvaluechanged', handleHeartRateNotification);
      } catch (error) {
        ui.statusElem.textContent = `Error: ${error.message}`;
        ui.statusElem.classList.add('text-red-600');
        ui.connectBtn.disabled = false;
      }
    }
    
    function handleHeartRateNotification(event) {
        const value = event.target.value;
        const flags = value.getUint8(0);
        const heartRate = (flags & 0x1) !== 0 ? value.getUint16(1, true) : value.getUint8(1);
        lastHR = heartRate;
        ui.hrDisplay.textContent = heartRate;
        
        if (sessionRunning && heartRate > 0) {
            hrHistory.push(heartRate);
            hrSum += heartRate;
            if (heartRate > maxHRInSession) {
                maxHRInSession = heartRate;
            }
        }
        
        updateFullScreenHeartRate(heartRate);

        if (heartRate > 0) {
            const animationDuration = 60 / heartRate;
            ui.heartIcon.style.animationDuration = `${animationDuration.toFixed(2)}s`;
            ui.heartIcon.classList.add('heartbeat-animation');
        } else {
            ui.heartIcon.classList.remove('heartbeat-animation');
        }
    }

    function onDisconnected() {
      ui.statusElem.textContent = 'Dispositivo desconectado.';
      ui.statusElem.classList.remove('text-green-600');
      ui.statusElem.classList.add('text-red-600');
      ui.hrDisplay.textContent = '--';
      if (heartRateCharacteristic) {
        heartRateCharacteristic.removeEventListener('characteristicvaluechanged', handleHeartRateNotification);
        heartRateCharacteristic = null;
      }
      updateFullScreenHeartRate('--');
      lastHR = null;
    }
    
    function isInZone(hr) {
      if (isNaN(hr)) return false;
      const z = ZONAS.find(x => x.id == zoneActual);
      return z && hr >= z.min && hr <= z.max;
    }
    
    function getIndicadorFlecha(hr) {
      if (isNaN(hr) || hr === '--') return 'ok';
      const z = ZONAS.find(x => x.id == zoneActual);
      if (!z) return 'ok';
      if (hr < z.min) return "arriba";
      if (hr > z.max) return "abajo";
      return "ok";
    }
    
    function getZoneClass(hr) {
        if (isNaN(hr) || hr === '--') return '';
        if (hr >= 170) return 'hr-red';
        const zone = ZONAS.find(z => hr >= z.min && hr <= z.max);
        if(zone) return `hr-${['blue','green','yellow','orange'][zone.id - 1]}`;
        return '';
    }

    function fitHeartRateFontSize() {
      if (!ui.hrProto) return;
      const media = window.matchMedia("(orientation: landscape)");
      const boxW = window.innerWidth * (media.matches ? 0.53 : 0.95);
      const boxH = window.innerHeight * (media.matches ? 0.93 : 0.33);
      ui.hrProto.textContent = '188';
      ui.hrProto.style.fontSize = '200px';
      const rect = ui.hrProto.getBoundingClientRect();
      const scale = Math.min(boxW / rect.width, boxH / rect.height, 1.17);
      ui.hrVisible.style.fontSize = (200 * scale) + 'px';
    }

    function updateFullScreenHeartRate(bpm) {
      ui.hrVisible.textContent = bpm;
      ui.hrVisible.classList.remove(...HR_ZONES_CLASSES);
      const zoneClass = getZoneClass(bpm);
      if (zoneClass) ui.hrVisible.classList.add(zoneClass);
      
      const arrowType = getIndicadorFlecha(bpm);
      ui.arrow.classList.remove('arriba', 'abajo', 'ok');
      ui.arrow.classList.add(arrowType);
      
      if (arrowType === 'arriba') {
          ui.arrow.innerHTML = "&#8593;";
      } else if (arrowType === 'abajo') {
          ui.arrow.innerHTML = "&#8595;";
      } else {
          ui.arrow.textContent = "";
      }

      if (ui.fullscreenContainer.classList.contains('active')) {
        fitHeartRateFontSize();
      }
    }
    
    // MODIFICADO: Ahora también activa el Wake Lock.
    function enterFullScreen() {
      ui.resultMsg.style.display = "none";
      ui.fullscreenContainer.classList.add('active');
      updateZoneVisuals();
      setTimeout(fitHeartRateFontSize, 50);
      if (ui.fullscreenContainer.requestFullscreen) ui.fullscreenContainer.requestFullscreen();
      // NUEVO: Solicita mantener la pantalla encendida.
      requestWakeLock();
    }

    function handleExitFullscreen() {
        ui.fullscreenContainer.classList.remove('active');
        if (sessionElapsed > 0) {
            const avgHR = hrHistory.length > 0 ? Math.round(hrSum / hrHistory.length) : 0;
            const adherence = Math.round(secondsInZone / Math.max(1, Math.floor(sessionElapsed / 1000)) * 100);
            
            ui.resultMsg.innerHTML = `Duración: <b>${formatDuration(sessionElapsed)}</b> | En Zona: <b>${adherence}%</b><br>
            FC Prom: <b>${avgHR}</b> bpm | FC Max: <b>${maxHRInSession}</b> bpm`;
            ui.resultMsg.style.display = "block";
        }
        // NUEVO: Libera el bloqueo de pantalla para ahorrar batería.
        releaseWakeLock();
    }

    // MODIFICADO: El comportamiento sigue igual pero ahora llamará a handleExitFullscreen que libera el lock.
    function exitFullScreen() {
      if (document.fullscreenElement) document.exitFullscreen();
      handleExitFullscreen();
    }

    // --- Inicialización y Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        loadCustomZones();
        updateZoneVisuals();
        updateFullScreenHeartRate('--');
        ui.sessionTime.textContent = "00:00:00";

        ui.connectBtn.addEventListener('click', connectToBluetooth);
        ui.playBtn.addEventListener('click', startSession);
        ui.pauseBtn.addEventListener('click', pauseSession);
        ui.resetBtn.addEventListener('click', resetSession);
        ui.fullscreenBtn.addEventListener('click', enterFullScreen);
        ui.exitFullscreenBtn.addEventListener('click', exitFullScreen);
        
        ui.editZonesBtn.addEventListener('click', openZoneEditor);
        ui.closeModalBtn.addEventListener('click', closeZoneEditor);
        ui.saveZonesBtn.addEventListener('click', saveZones);
        ui.calculateZonesBtn.addEventListener('click', calculateZonesByAge);

        ui.zoneBtnsRow.addEventListener('click', (event) => {
            const clickedBtn = event.target.closest('.zone-btn');
            if (!clickedBtn) return;
            zoneActual = parseInt(clickedBtn.dataset.zoneId, 10);
            updateZoneVisuals();
            updateFullScreenHeartRate(lastHR ?? '--');
        });

        window.addEventListener('resize', () => {
            if (ui.fullscreenContainer.classList.contains('active')) fitHeartRateFontSize();
        });
        
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && ui.fullscreenContainer.classList.contains('active')) {
                handleExitFullscreen();
            }
        });

        // NUEVO: Listener para readquirir el Wake Lock si la página vuelve a ser visible.
        document.addEventListener('visibilitychange', () => {
            // Si la página vuelve a estar visible, no hay un lock activo, y estábamos en modo fullscreen...
            if (document.visibilityState === 'visible' && wakeLock === null && ui.fullscreenContainer.classList.contains('active')) {
                // ...entonces intentamos readquirir el lock.
                requestWakeLock();
            }
        });
    });
</script>
